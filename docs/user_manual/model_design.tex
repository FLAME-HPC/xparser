\section{Model Design}
\label{model_design}

The philosophy of FLAME is to specify an agent-based model as one would
specify software behaviour, as ultimately the execution of the model will be in
software. Traditionally specifying software behaviour has used finite state
machines which allow modelling of a system in terms of its inputs and outputs.
Testing a system specified as a finite state machine makes it easier for the behaviour to be expressed as a graph
and allow traversals of all possible and impossible executions of the system.
Conventional state machines describe the state-dependent behaviour of a system 
in terms of its inputs, but this fails to include the effect of data.
X-Machines are an extension to conventional state machines that
include the manipulation of memory as part of the system behaviour,
and thus are a suitable way to specify agents.
Describing a system would thus include the following individual
stages for creating a model:

\begin{itemize}
\item Identifying the agent functions
\item Identify the states which impose some order of function execution
\item Identify the input messages and output messages of each function,
including filters on inputs
\item Identify the memory as the set of variables that are accessed by
transition functions, including conditions on variables for the transition to
occur
\end{itemize}

For example a simple swarm model would include agents with the functions:

\begin{itemize}
\item signal -- send out current position
\item observe -- read positions from other agents and change velocity
\item respond -- update position via velocity
\end{itemize}

The functions occur in the above order so states are included to impose this
order. As a requirement for automatic parallel execution functions can only be
executed once. There can only be one start state, but there can be many end
states.

\begin{figure}[h]
\begin{center}
\includegraphics*[scale=0.5]{swarm_1.ps}
\caption{Swarm model including states}
\label{fig:swarm_1}
\end{center}
\end{figure}

Functions can also have conditions on the memory of an agent. For instance lets
say we have a response function for flying and a response function when resting
on the ground. The condition on the flying response function would be that the
z-axis position of the agent be greater than zero while the resting response
function condition would be when the z-axis position was zero.

\begin{figure}[h]
\begin{center}
\includegraphics*[scale=0.5]{swarm_2.ps}
\caption{Swarm model including function conditions}
\label{fig:swarm_2}
\end{center}
\end{figure}

The messages required for communication are a signal message, which is output
from signal and input to observe. This message would include the position of the
agent that sent it. A feature of swarm models and most agent-based models is that
there is generally a limit on incoming communication. In the swarm case this is
the perceived distance of sight that an agent can view the location of other
agents. This feature can be added to the model as a filter on inputs to a
function, where the filter is a formula involving the position contained in the
message and the agent position.

\begin{figure}[h]
\begin{center}
\includegraphics*[scale=0.5]{swarm_3.ps}
\caption{Swarm model including messages}
\label{fig:swarm_3}
\end{center}
\end{figure}

Finally the memory required by the agent functions include the position of the
agent, and its velocity, as shown in Table \ref{tab:swarm_memory}.

\begin{table}[h]
\centering
\begin{tabular}{|l||c||l|}
\hline
Type&Name&Description\\
\hline \hline
double&px&position in x-axis\\
\hline
double&py&position in y-axis\\
\hline
double&pz&position in z-axis\\
\hline
double&vx&velocity in x-axis\\
\hline
double&vy&velocity in y-axis\\
\hline
double&vz&velocity in z-axis\\
\hline
\end{tabular}
\caption{Swarm Agent Memory}
\label{tab:swarm_memory}
\end{table}

Chapter \ref{model_description} on model description describes how to write a
model description into an XML file that FLAME can understand. Chapter
\ref{model_implementation} on model implementation describes how to implement
the individual agent functions. 

% \begin{equation}\label{streamxmachine}
%     X = (\Sigma, \Gamma, Q, M, \Phi, F, q_{0}, m_{0})
% \end{equation}
% where,
% \begin{itemize}
% \item $\Sigma$ are the set of input alphabets
% \item $\Gamma$ are the set of output alphabets
% \item $Q$ denotes the set of states
% \item $M$ denotes the variables in the memory.
% \item $\Phi$ denotes the set of partial functions $\phi$ that map
% and input and memory variable to an output and a change on the
% memory variable. The set $\phi$: $\Sigma \times M\ \longrightarrow\
% \Gamma\times M$
% \item $F$ in the next state transition function, $F : Q \times\phi\longrightarrow
% Q$
% \item $q_{0}$ is the initial state and $m_{0}$ is the initial memory
% of the machine.
% \end{itemize}
% 
% \subsection{Transition Function}
% The transition functions allow the agents to change the state in
% which they are in, modifying their behaviour accordingly. These would
% require as inputs their current state $s_{1}$, current memory value
% $m_{1}$, and the possible arrival of a message that the agent is able to
% read, $t_{1}$. Depending on these three values the agent can then
% change to another state $s_{2}$, updates the memory to $m_{2}$ and
% optionally sends a message, $t_{2}$. Figure
% \ref{fig:trans} depicts how the transition function
% works within the agent.
% 
% % \begin{figure}
% % \begin{center}
% % \includegraphics*[scale=0.5]{transfn.eps}
% % \caption{Transition function} \label{fig:trans}
% % \end{center}
% % \end{figure}
% 
% 
% Extended finite state machines or X-Machines are used to define agents within a
% model. 
% The basic definition of an
% agent would thus, in accordance to the computational model, contain
% the following components:
% \begin{enumerate}
%  \item A finite set of internal states.
%  \item A set of transition functions that operate between states.
%  \item An internal memory set. In practice, the memory would be a finite set and can be structured in any way required.
%  \item A language for sending and receiving messages between other agents.
% \end{enumerate}
% 
% 
% Some of the transition functions may not depend on the incoming
% message. Thus the message would then be represented as:
% \begin{equation}\label{msg}
%     Message = \{ \emptyset, <data> \}
% \end{equation}
% 
% These agent transition functions may be expressed in terms of
% stochastic rules, thus allowing the multi-agent systems to be termed
% as stochastic systems.
% 
% \subsubsection{Memory and States}
% The difference between the internal set of states and the internal
% memory set allows for added flexibility when modelling systems.
% There can be agents with one internal state and all the complexity
% defined in the memory or equivalently, there could be agents with
% a trivial memory with the complexity then bound up in a large state
% space. There are good examples of choosing an appropriate balance
% between these two as this enables the complexity of the models to be
% better managed.

% \begin{figure}
% \begin{center}
% \includegraphics*[width = 4in]{X-Machine_agent.eps}
% \caption{X-Machine agent} \label{fig:xmachine}
% \end{center}
% \end{figure}

