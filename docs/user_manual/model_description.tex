\section{Model Description}
\label{model_description}

Models descriptions are formatted in XML tag structures to allow
easy human and computer readability.

The DTD (Document Type Definition) of the XML document is currently located
here:

http://eurace.cs.bilgi.edu.tr/XMML.dtd

The start and end of a model file should be formatted as follows:

\begin{mylisting}
\begin{verbatim}
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE xmodel SYSTEM "http://eurace.cs.bilgi.edu.tr/XMML.dtd">
<xmodel version="2">
<name>Model_name</name>
<version>the version</version>
<description>a description</description>
...
</xmodel>
\end{verbatim}
\end{mylisting}

Models can contain:
\begin{itemize}
\item other models (enabled or disabled)
\item \textbf{environment}
\begin{itemize}
\item constant variables
\item location of function files
\item time units
% \begin{itemize}
% \item name
% \item *** unit
% \item *** period
% \end{itemize}
\item data types
% \begin{itemize}
% \item name
% \item description
% \item variables
% \end{itemize}
\end{itemize}
\item \textbf{agent types}
\begin{itemize}
\item name
\item description
\item memory
% *** variables
\item functions
% *** name
% *** description
% *** current state
% *** next state
% *** condition
% *** inputs
% **** filter
% *** outputs
\end{itemize}
\item \textbf{message types}
\begin{itemize}
\item name
\item description
\item variables
\end{itemize}
\end{itemize}

\subsection{Model in Multiple Files}

It is possible to define a model in multiple files. FLAME reads a model from
multiple files as if the model was defined in one file. This capability allows
different parts of a model to be enabled or disabled easily. For example if a
model includes different versions of a sub-model that can be exchanged, or a
subsystem of a model can be disabled to see how it affects the model.
Alternatively this capability could be used as a hierarchy, for example a `body'
model could include a model of the `cardiovascular system' that includes a
model of the `heart'. The following tags show the inclusion of two models, one
enabled and one disabled:

\begin{mylisting}
\begin{verbatim}
<models>
  <model><file>sub_model_1.xml</file><enabled>true</enabled></model>
  <model><file>sub_model_2.xml</file><enabled>false</enabled></model>
</models>
\end{verbatim}
\end{mylisting}

\subsection{Environment}

The environment of a model holds information required by FLAME but is not part
of an agent or a message. This includes:

\begin{itemize}
\item constant variables -- for setting up different simulations easily
\item location of function files -- the path to the implementations of agent
functions
\item time units -- for easily activating agent functions dependent on time
periods
\item data types -- user defined data types used by agent memory or
message variables
\end{itemize}

\subsubsection{Constant Variables}

These are constant variables that can be set as part of a simulation runs
initial starting values, and can be defined as follows:

\begin{mylisting}
\begin{verbatim}
<constants>
  <variable>
   <type>int</type><name>my_constant</name>
   <description>value read in initial simulation settings</description>
  </variable>
</constants>
\end{verbatim}
\end{mylisting}

% Constant Variables refers to the global values used in the model. These can me
% defined in a separate header file which can then be included in one of the
% functions file.
% 
% The header file would look as follows:
% 
% \begin{mylisting}
% \begin{verbatim}
% #define <varname> <value>
% \end{verbatim}
% \end{mylisting}
% 
% If this file was saved as a `my\_header.h' file, include this file into one of
% the function files so that the compiler knows about these arguments.

\subsubsection{Function Files}

Function files hold the source code for the implementation of the
agent functions.
They are included in the compilation script (Makefile) of the produced model:

\begin{mylisting}
\begin{verbatim}
 <functionFiles>
 <file>function_source_code_1.c</file>
 <file>function_source_code_2.c</file>
 </functionFiles>
\end{verbatim}
\end{mylisting}

\subsubsection{Time Units}
\label{timeunit}

% Time units allow the possibility of restricting the functions to
% only execute during particular iterations.
% Time rules can be applied to function conditions instead of a
% condition rule and are defined by a time period and a phase. A time
% phase is the offset from the start of a period.

Time units are used to define time periods that agent functions act within. For
example a model that uses a calendar based time system could take a day to be
the smallest time step, i.e. one iteration. Other time units can then use this
definition to define other time units, for example weeks, months, and years.

A time unit contains:

\begin{itemize}
\item name -- name of the time unit.
\item unit -- can contain `iteration' or other defined time units.
\item period -- the length of the time unit using the above units.
\end{itemize}

An example of a calendar based time unit set up is given below:

\begin{mylisting}
\begin{verbatim}
<timeUnits>
  <timeUnit>
    <name>daily</name>
    <unit>iteration</unit>
    <period>1</period>
  </timeUnit>

  <timeUnit>
    <name>weekly</name>
    <unit>daily</unit>
    <period>5</period>
  </timeUnit>

  <timeUnit>
    <name>monthly</name>
    <unit>weekly</unit>
    <period>4</period>
  </timeUnit>

  <timeUnit>
    <name>quarterly</name>
    <unit>monthly</unit>
    <period>3</period>
  </timeUnit>

  <timeUnit>
    <name>yearly</name>
    <unit>monthly</unit>
    <period>12</period>
  </timeUnit>

</timeUnits>
\end{verbatim}
\end{mylisting}

\subsubsection{Data Types}

Data types are user defined data types that can be used in a model.
Data types can contain C data types or other predefined user data types.
The example below the data type \emph{line} contains a variable
of data type \emph{position} which is defined above it:

\begin{mylisting}
\begin{verbatim}
<dataTypes>

 <dataType>
  <name>position/name>
  <description>position in 3D using doubles</description>
  <variables>
   <variable><type>double</type><name>x</name>
    <description>position on x-axis</description>
   </variable>
   <variable><type>double</type><name>y</name>
    <description>position on y-axis</description>
   </variable>
   <variable><type>double</type><name>z</name>
    <description>position on z-axis</description>
   </variable>
  </variables>
 </dataType>

 <dataType>
  <name>line</name>
  <description>a line defined by two points</description>
  <variables>
   <variable><type>position</type><name>start</name>
    <description>start position of the line</description>
   </variable>
   <variable><type>position</type><name>end</name>
    <description>end position of the line</description>
   </variable>
  </variables>
 </dataType>

</dataTypes>
\end{verbatim}
\end{mylisting}

\subsection{Agent}

An agent type contains a name, a description, memory, and functions. 

\begin{mylisting}
\begin{verbatim}
<agents>

  <xagent>
    <name>Agent_Name</name>
    <description></description>
    <memory>
     ...
    </memory>
    <functions>
      ...
    </functions>
  </xagent>

  <xagent>
    <name>Household</name>
    <description></description>
    <memory>
      <variable><type>int</type><name>id</name>
       <description></description>
      </variable>
      <variable><type>int</type><name>region_id</name>
       <description></description>
      </variable>
      <variable><type>int_array</type><name>neighboring_region_ids</name>
       <description></description>
      </variable>
      <variable><type>int</type><name>gov_id</name>
       <description></description>
      </variable>
      <variable><type>int</type><name>day_of_month_to_act</name>
       <description></description>
      </variable>
      <variable><type>double</type><name>payment_account</name>
       <description></description>
      </variable>
    </memory>
    <functions>
     <function>
       <name>Household_read_firing_messages</name>
        <description>Check for being fired or not</description>
        <currentState>EXIT_FINANCIAL_MARKET</currentState>
        <nextState>01d</nextState>
        <condition>
         <lhs><value>a.employee_firm_id</value></lhs>
         <op>NEQ</op>
         <rhs><value>-1</value></rhs>
        </condition>
        <inputs>
         <input><messageName>firing</messageName></input>
        </inputs>
      </function>
    </functions>
  </xagent>
</agents>
\end{verbatim}
\end{mylisting}

\subsubsection{Agent Memory}

Agent memory defines variables, where variables are defined by their type, C
data types or user defined data types from the environment, a name, and a
description:

\begin{mylisting}
\begin{verbatim}
memory>
 <variable><type>int</type><name>id</name>
  <description>identity number</description>
 </variable>
 <variable><type>double</type><name>x</name>
  <description>position in x-axis</description>
 </variable>
</memory>
\end{verbatim}
\end{mylisting}

\subsubsection{Agent Functions}

An agent function contains:

\begin{itemize}
\item name
\item description
\item current state - the current state the agent has to be in.
\item next state - the next state the agent will transition to.
\item condition - a possible condition of the function transition.
\item inputs - the possible input messages.
\item outputs - the possible output messages.
\end{itemize}

\subsubsection{Function Condition}
\label{functioncond}

A function can have a condition on its transition. This condition can include
conditions on the agent memory and also on any time units defined in the
environment. At any state with outgoing transitions with conditions it must be
possible for a transition to happen, i.e. it must be possible for every agent
to transition from the start state to an end state.

Conditions (that are not only time unit based) take the form:

\begin{itemize}
  \item lhs -- left hand side of comparison
  \item op -- the comparison operator
  \item rhs -- the right hand side of the comparison
\end{itemize}

Or in tags:

\begin{mylisting}
\begin{verbatim}
<lhs></lhs><op></op><rhs></rhs>
\end{verbatim}
\end{mylisting}

Sides to compare (lhs or rhs) can be either a value, denoted by value tags, 
a formula, currently also in value tags, or another comparion rule.
Values and formula can include agent variables which are preceded by `a.'.

% \begin{mylisting}
% \begin{verbatim}
% a.agent_var
% m.message_var
% \end{verbatim}
% \end{mylisting}

The comparison operator can be one of the following comparison functions:

\begin{itemize}
\item EQ -- equal to
\item NEQ -- not equal to
\item LEQ -- less than or equal to
\item GEQ -- greater than or equal to
\item LT -- less then
\item GT -- greater than
\end{itemize}

or can be one of the following logic operators as well:

\begin{itemize}
\item AND
\item OR
\end{itemize}

The operator `NOT' is used by placing `not' tags around a comparison rule.

\begin{mylisting}
\begin{verbatim}
<condition>
 <lhs>
  <lhs><value>a.z</value></lhs>
  <op>GT</op>
  <rhs><value>0</value></rhs>
 </lhs>
 <op>AND</op>
 <rhs>
  <not>
  <lhs><value>a.z</value></lhs>
  <op>ELT</op>
  <rhs><value>10.0</value></rhs>
  </not>
 </rhs>
</condition>
\end{verbatim}
\end{mylisting}

A condition can then be added to the function definition to make the
parser aware that this particular function only has to be called at
certain times of the simulation. The condition can be added as
follows:

\begin{mylisting}
\begin{verbatim}
 <condition>
     <time>
     <period>monthly</period>
     <phase>a.day_of_month_to_act</phase>
     </time>
 </condition>
\end{verbatim}
\end{mylisting}

The condition allows the function to run \emph{monthly} at the phase
of \emph{day\_of\_month\_to\_act}. The
\emph{day\_of\_month\_to\_act} is a variable extracted from the
agent memory and is thus defined as
\emph{a.day\_of\_month\_to\_act}.

Refer to section \ref{functioncond} for more details on function
condition definitions.

These rules are then parsed into rule functions and placed in a file
called rules.c

\paragraph{Message Filter}
Message filters allow the messages to be filtered before being
provided to the function. This allows the messages to be checked
according to a condition before being read by the function. The
message filter can be added as follows:

\begin{mylisting}
\begin{verbatim}
<input>
 <messageName>firing</messageName>
 <filter>
  <lhs><value>a.id</value></lhs>
  <op>EQ</op>
  <rhs><value>m.worker_id</value></rhs>
 </filter>
</input>
\end{verbatim}
\end{mylisting}

Thus in the above example messages will be filtered according to the
message variable \emph{worker\_id} (defined as m.<varname>) to be EQ
(equal) to the agent \emph{id} (defined as a.<varname>).

\subsection{Messages}

The agents are communicating with each other through messages being
sent in the system. The messages being processed have to be defined
in the XML file. All message lists are emptied at the end of the
iteration.

\begin{mylisting}
\begin{verbatim}
<messages>

 <message>
  <name>bank_account_update</name>
  <description>
   Household informs the bank about the actual payment account
  </description>
  <variables>
    <variable><type>int</type><name>id</name>
     <description></description>
    </variable>
    <variable><type>int</type><name>bank_id</name>
     <description></description>
    </variable>
    <variable><type>double</type><name>payment_account</name>
     <description></description>
    </variable>
  </variables>
 </message>

 <message>
  <name>application_rejection</name>
  <description>
   Send by firms. Includes the id and the id of the refused applicant.
  </description>
  <variables>
    <variable><type>int</type><name>firm_id</name>
     <description></description>
    </variable>
    <variable><type>int</type><name>worker_id</name>
     <description></description>
    </variable>
  </variables>
 </message>

</messages>
\end{verbatim}
\end{mylisting}
