/**
 * \file  messageboards.c
 * \brief Holds message board functions.
 */

#include "header.h"

<?foreach message?>
/** \fn xmachine_message_$name * add_$name_message_internal()
 * \brief Add $name message to the local message list.
 * \return The added message.
 */
xmachine_message_$name * add_$name_message_internal()
{
	xmachine_message_$name * current = (xmachine_message_$name *)malloc(sizeof(xmachine_message_$name));
	current->next = *p_$name_message;
	*p_$name_message = current;
	
	return current;
}

/** \fn void process_$name_message(xmachine_message_$name * current)
 * \brief Process $name message to calculate if it needs to be sent to another node.
 * \param current The message to be processed.
 */
void process_$name_message(xmachine_message_$name * current)
{
	double x = 0.0;
	double y = 0.0;
	double z = 0.0;
	double temp_space_partition[6];
	double max_mess_dist;
	int in_halo_region = 0;
	node_information * node_info;
	xmachine_message_$name * temp_send_message;
	<?foreach xagent?>
	if(current_xmachine->xmachine_$name)
	{
		max_mess_dist = current_xmachine->xmachine_$name->iradius;
		x = (double)current_xmachine->xmachine_$name->$xvar;
		y = (double)current_xmachine->xmachine_$name->$yvar;
<?if use_zvar?>		z = (double)current_xmachine->xmachine_$name->$zvar;<?end if?><?if no_zvar?>		z = 0.0;<?end if?>
	}<?end foreach?>
	
	/* Check x-axis halo region */
	if((current_node->partition_data[0] != -SPINF && x <= (current_node->partition_data[0]+max_mess_dist)) ||
	   (current_node->partition_data[1] !=  SPINF && x >= (current_node->partition_data[1]-max_mess_dist)))
	{ in_halo_region = 1; }
	/* Check y-axis halo region */
	if((current_node->partition_data[2] != -SPINF && y <= (current_node->partition_data[2]+max_mess_dist)) ||
	   (current_node->partition_data[3] !=  SPINF && y >= (current_node->partition_data[3]-max_mess_dist)))
	{ in_halo_region = 1; }
	/* Check z-axis halo region */
<?foreach xagent?><?if use_zvar?>	if(current_xmachine->xmachine_$name)
	{
		if(current_node->partition_data[4] != -SPINF && z <= current_node->partition_data[4]+max_mess_dist)
		{ in_halo_region = 1; }
		if(current_node->partition_data[5] != SPINF && z >= current_node->partition_data[5]-max_mess_dist)
		{ in_halo_region = 1; }
	}<?end if?><?end foreach?>
	
	if(in_halo_region)
	{
		node_info = *p_node_info;
		while(node_info)
		{
			if(node_info->node_id != current_node->node_id &&
			node_info->partition_data[0]-max_mess_dist < x && node_info->partition_data[1]+max_mess_dist > x &&
			node_info->partition_data[2]-max_mess_dist < y && node_info->partition_data[3]+max_mess_dist > y)
			{
				p_$name_message = &node_info->$name_messages;
				temp_send_message = add_$name_message_internal();
<?foreach messagevar?>				temp_send_message->$name = current->$name;
<?end foreach?><?if parallel?>				node_info->$name_message_no++;
<?end if?>			}
			node_info = node_info->next;
		}
		
		p_$name_message = &current_node->$name_messages;
	}
}

/** \fn void add_$name_message(<?foreach messagevar?>$type $name<?if notlast?>, <?end if?><?end foreach?>)
 * \brief Add $name message by calling internal and processing.
<?foreach messagevar?> * \param $name Message variable.
<?end foreach?> */
void add_$name_message(<?foreach messagevar?>$type $name<?if notlast?>, <?end if?><?end foreach?>)
{
	xmachine_message_$name * tmp = add_$name_message_internal();
<?foreach messagevar?>	tmp->$name = $name;
<?end foreach?>
	/* Check if agent in halo region */
	process_$name_message(tmp);
}

/** \fn xmachine_message_$name * get_first_$name_message()
 * \brief Get the first $name message in the $name message list.
 * \return The first message in the list.
 */
xmachine_message_$name * get_first_$name_message()
{
	return *p_$name_message;
}

/** \fn xmachine_message_$name * get_next_$name_message(xmachine_message_$name * current)
 * \brief Get the next $name message in the $name message list after the current message.
 * \param current The current message in the list.
 * \return The next message in the list.
 */
xmachine_message_$name * get_next_$name_message(xmachine_message_$name * current)
{
	return  current->next;
}

/** \fn void free$namemessages()
 * \brief Free the $name message list.
 */
void free$namemessages()
{
	xmachine_message_$name * tmp, * head;
	head = *p_$name_message;
	
	while(head)
	{
		tmp = head->next;
		free(head);
		head = tmp;
	}
	
	*p_$name_message = NULL;
}
<?end foreach?>
<?if parallel?>
/** \fn send_message_pack(node_information * node_info, int buffersize)
 * \brief Send a packed MPI message.
 */
void send_message_pack(node_information * node_info, int buffersize)
{
	int data[$number_messagesplusone];
	int i, position = 0;
	char buf[buffersize];
	data[0] = buffersize;
<?foreach message?>	data[$message_countplusone] = node_info->$name_message_no;
	xmachine_message_$name_data $name_message_list[node_info->$name_message_no];
	xmachine_message_$name * temp_message_$name;
<?end foreach?>
	MPI_Send(&data, $number_messagesplusone, MPI_INT, node_info->node_id, 15, MPI_COMM_WORLD);
	if(buffersize > 0)
	{
<?foreach message?>		i = 0;
		temp_message_$name = node_info->$name_messages;
		while(temp_message_$name)
		{
<?foreach messagevar?>			$messagename_message_list[i].$name = temp_message_$messagename->$name;
<?end foreach?>			i++;
			
			temp_message_$name = temp_message_$name->next;
		}
		MPI_Pack($name_message_list, node_info->$name_message_no, message$nameType, buf, buffersize, &position, MPI_COMM_WORLD);
		
<?end foreach?>		MPI_Send(buf, position, MPI_PACKED, node_info->node_id, 19, MPI_COMM_WORLD);
	}
}
/** \fn void receive_message_pack(node_information * node_info, int buffersize, <?foreach message?>int $name_message_no<?if notlast?>, <?end if?><?end foreach?>)
 * \brief Receive a packed MPI message.
 */
void receive_message_pack(node_information * node_info, int buffersize, <?foreach message?>int $name_message_no<?if notlast?>, <?end if?><?end foreach?>)
{
		char buf[buffersize];
		int checkbuffersize, i, position = 0;
<?foreach message?>		xmachine_message_$name * temp_message_$name;
		xmachine_message_$name_data $name_message_list[$name_message_no];
<?end foreach?>		MPI_Recv(buf, buffersize, MPI_PACKED, node_info->node_id, 19, MPI_COMM_WORLD, &status);
		MPI_Get_count(&status, MPI_PACKED, &checkbuffersize);
<?foreach message?>
		MPI_Unpack(buf, checkbuffersize, &position, &$name_message_list, $name_message_no, message$nameType, MPI_COMM_WORLD);
		for(i=0; i<$name_message_no; i++)
		{
			temp_message_$name = add_$name_message_internal();
<?foreach messagevar?>			temp_message_$messagename->$name = $messagename_message_list[i].$name;
<?end foreach?>		}
<?end foreach?>}

/** \fn void propagate_messages()
 * \brief Propagate messages between nodes via packed MPI messages.
 */
void propagate_messages()
{
	int buffersize;
	node_information * node_info;
	int data[$number_messagesplusone];
	int i, packsize;
	
	/* Send pack data and pack */
	node_info = *p_node_info;
	while(node_info)
	{
		if(node_number != node_info->node_id)
		{
			buffersize = 0;
<?foreach message?>			MPI_Pack_size(node_info->$name_message_no, message$nameType, MPI_COMM_WORLD, &packsize);
			buffersize += packsize;
<?end foreach?>			send_message_pack(node_info, buffersize);
		}
		
		node_info = node_info->next;
	}
	
	/* Receive pack data */
	node_info = *p_node_info;
	while(node_info)
	{
		if(node_number != node_info->node_id)
		{
			MPI_Recv(&data, $number_messagesplusone, MPI_INT, node_info->node_id, 15, MPI_COMM_WORLD, &status);
			
			if(data[0] > 0) receive_message_pack(node_info, data[0]<?foreach message?>, data[$message_countplusone]<?end foreach?>);
<?foreach message?>			p_$name_message = &node_info->$name_messages;
			free$namemessages();
			node_info->$name_message_no = 0;
			p_$name_message = &current_node->$name_messages;
<?end foreach?>		}
		
		node_info = node_info->next;
	}
}
<?end if?>